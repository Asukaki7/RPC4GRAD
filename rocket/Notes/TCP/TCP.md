## half close

在Socket编程中，**半关闭（Half-Close）** 是指TCP连接的一端关闭了**发送数据**的能力，但仍保留**接收数据**能力的状态。这种状态通常通过调用 `shutdown()` 函数实现（而非 `close()`），用于通知对方“我不会再发送数据，但可以继续接收你的数据”。

---

### **半关闭的核心机制**
1. **TCP协议特性**  
   TCP是全双工协议，允许双方同时发送和接收数据。半关闭利用了这一点，通过发送 `FIN` 报文表示结束发送方向，但保留接收方向通道的开放。

2. **实现方式**  
   调用 `shutdown(socket_fd, SHUT_WR)`（关闭**写端**）：
   - 本地发送缓冲区中的数据会被发送，随后发送 `FIN` 报文给对方。
   - 对方收到 `FIN` 后，会回复 `ACK`，但对方仍可继续发送数据。
   - 本地仍可以通过 `recv()` 接收对方的数据。

---

### **半关闭 vs 完全关闭**
| **操作**               | **行为**                                                                 |
|------------------------|--------------------------------------------------------------------------|
| `shutdown(SHUT_WR)`     | 关闭发送方向，发送 `FIN`；保留接收能力，可继续读取对方数据。              |
| `close()`               | 直接关闭双向通信，释放资源；若有多进程共享套接字，仅减少引用计数。        |

---

### **典型应用场景**
1. **HTTP协议**  
   客户端发送完HTTP请求后，可以半关闭写端（`SHUT_WR`），表示不再发送数据，但仍等待服务器返回响应。

2. **文件传输确认**  
   发送方传输完文件后，半关闭写端，但仍保持读端开放以接收接收方的确认消息。

3. **协议控制**  
   当一方需要明确告知对方“数据已发送完毕”但仍需接收结果时（如数据库查询）。

---

### **代码示例（C语言）**
```c
// 客户端发送完数据后，半关闭写端
send(socket_fd, data, data_len, 0);
shutdown(socket_fd, SHUT_WR);  // 发送FIN，不再发送数据

// 但仍可以接收服务器的响应
while ((n = recv(socket_fd, buffer, sizeof(buffer), 0)) > 0) {
    // 处理数据...
}

// 完全关闭连接
close(socket_fd);
```

---

### **注意事项**
1. **正确处理接收逻辑**  
   半关闭后，需持续调用 `recv()` 直到返回 `0`（表示对方也关闭了连接）。

2. **资源释放**  
   最终仍需调用 `close()` 释放套接字资源。

3. **协议兼容性**  
   并非所有协议都支持半关闭（如UDP无连接，无此概念），需根据具体协议设计逻辑。

---

### **总结**
半关闭是TCP全双工特性的灵活应用，允许单向数据流的终止，常用于需要明确结束发送但仍需接收数据的场景。通过 `shutdown()` 实现，与 `close()` 的区别在于对双向通信的控制粒度。